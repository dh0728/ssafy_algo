import sys
sys.stdin = open('input.txt')

T=int(input())
for tc in range(1,T+1):
    arr=list(map(int,input().split()))
    result=0
    n = len(arr)
    sum_set=0
    for i in range(1,1<<n):  # 1<<n 2**n
        sum_set = 0          # i의 값은 각 부분집합의 위치 i=5 => 이진법(101)에서 1의 위치 = arr의 시작부터 했을 때의 값의 위치 == [19,0,16,0,0,0,0,0,0,0]
        for j in range(n):
            if i & (1<<j):  # 1<<J(1,10,100,1000 ... 1000000000)와 i의 bit위치를 비트연산자를 현재 부분집합에서 어떤위치의 값을 가지고 있는지 확인
                sum_set+=arr[j] # 부분집합이 가진 값을 더하기
        if sum_set==0:  #결과
            result=1
            break
    print(f'#{tc} {result}')

# 비트시프트 연산자 <<
#오른쪽으로 0이 주어진 개수 만큼 추가 되는 것
# 1<<0  =      1  2^0 = 1
# 1<<1  =     10  2^1 = 2
# 1<<2  =    100  2^2 = 4
# 1<<5  = 100000  2^5 = 32

# 예시=[1,2,3,4,5]
#        2진법       부분집합       bit_arr
# i=1       1   [ , , , ,5] =  [0,0,0,0,1]
# i=2      10   [ , , ,4, ] =  [0,0,0,1,0]
# i=3      11   [ , , ,4,5] =  [0,0,0,1,1]
# i=4     100   [ , ,3, , ] =  [0,0,1,0,0]
# i=5     101   [ , ,3, ,5] =  [0,0,1,0,1]
# i=31  11111   [1,2,3,4,5] =  [1,1,1,1,1]

# 비트 연산자 &
# 동일한 위치의 bit가 1인 것을 뽑아내는 것
#    2진법       부분집합       bit_arr
# 4 = 100   [ , ,3, , ] =  [0,0,1,0,0]
# 5 = 101   [ , ,3, ,5] =  [0,0,1,0,1]
# -----------------------------------
# 결과 100 => 2^2 = 4

