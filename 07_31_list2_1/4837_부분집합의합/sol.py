T = int(input())
A = list(range(1, 13)) #[1,2,3,4,5,6,7,8,9,10,11,12]

for testcase in range(1, T + 1):
    N, K = map(int, input().split()) # N:부분집합의 개수, K:부분집합의 합

    cnt = 0
    for i in range(1 << 12):  # 부분집합의 개수만큼 반복(2**n)
        subset = []           # i의 값은 각 부분집합의 값의 위치 i=5 => 이진법(101)에서 1의 위치 = arr의 시작부터 했을 때의 값의 위치 == [1,0,5,0,0...]
        for j in range(12):  # 원소의 수만큼 비트를 비교
            if i & (1 << j):  # 1<<J(1,10,100,1000, 10000, 100000 ...)와 i의 bit위치를 비트연산자를 현재 부분집합에서 어떤위치의 값을 가지고 있는지 확인
                subset.append(A[j])  # j번 원소를 subset에 넣어라
        if len(subset) == N and sum(subset) == K:
            cnt += 1

    print(f'#{testcase} {cnt}')

    # 비트시프트 연산자 <<
    # 오른쪽으로 0이 주어진 개수 만큼 추가 되는
    # 1<<0  =      1  2^0 = 1
    # 1<<1  =     10  2^1 = 2
    # 1<<2  =    100  2^2 = 4
    # 1<<5  = 100000  2^5 = 32

    # 예시=[1,2,3,4,5]
    #        2진법       부분집합       bit_arr      문제에서 i에 따른 A의 부분집합
    # i=1       1   [ , , , ,5] =  [0,0,0,0,1] => [1, , , , ...] =  [1,0,0,0,0 ...]
    # i=2      10   [ , , ,4, ] =  [0,0,0,1,0] => [ ,2, , , ...] =  [0,1,0,0,0 ...]
    # i=3      11   [ , , ,4,5] =  [0,0,0,1,1] => [1,2, , , ...] =  [1,1,0,0,0 ...]
    # i=4     100   [ , ,3, , ] =  [0,0,1,0,0] => [ , ,3, , ...] =  [0,0,1,0,0 ...]
    # i=5     101   [ , ,3, ,5] =  [0,0,1,0,1] => [1, ,3, , ...] =  [1,0,1,0,0 ...]
    # i=5     111   [ , ,3,4,5] =  [0,0,1,1,1] => [1,2,3, , ...] =  [1,1,1,0,0 ...]
    # i=31  11111   [1,2,3,4,5] =  [1,1,1,1,1] => [1,2,3,4,5...] =  [1,1,1,1,1 ...]

    # 비트 연산자 &
    # 동일한 위치의 bit가 1인 것을 뽑아내는 것
    #    2진법       부분집합       bit_arr
    # 4 = 100   [ , ,3, , ] =  [0,0,1,0,0]
    # 5 = 101   [ , ,3, ,5] =  [0,0,1,0,1]
    # -----------------------------------
    # 결과 100 => 2^2 = 4